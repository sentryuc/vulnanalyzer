#!/usr/bin/env python3

import json
import requests
import subprocess
import os
from datetime import datetime
from core.utils import generate_random_id, get_timestamp


class Exploiter:
    def __init__(self, scan_results):
        """Initialize the Exploiter with scan results."""
        self.scan_results = scan_results
        self.exploits_db = self._load_exploits_database()
        
    def _load_exploits_database(self):
        """Load the exploits database."""
        return {
            "web": [
                {
                    "name": "SQL Injection Basic",
                    "description": "Basic SQL injection test",
                    "cve": "N/A",
                    "target_service": "http",
                    "severity": "high",
                    "payload": "' OR '1'='1",
                    "method": "GET"
                },
                {
                    "name": "XSS Reflected",
                    "description": "Reflected Cross-Site Scripting",
                    "cve": "N/A",
                    "target_service": "http",
                    "severity": "medium",
                    "payload": "<script>alert('XSS')</script>",
                    "method": "GET"
                },
                {
                    "name": "Directory Traversal",
                    "description": "Path traversal vulnerability",
                    "cve": "N/A",
                    "target_service": "http",
                    "severity": "medium",
                    "payload": "../../../etc/passwd",
                    "method": "GET"
                }
            ],
            "network": [
                {
                    "name": "SSH Brute Force",
                    "description": "SSH password brute force attack",
                    "cve": "N/A",
                    "target_service": "ssh",
                    "severity": "high",
                    "port": 22,
                    "usernames": ["admin", "root", "user", "test"],
                    "passwords": ["password", "123456", "admin", "root"]
                },
                {
                    "name": "FTP Anonymous Login",
                    "description": "Test for anonymous FTP access",
                    "cve": "N/A",
                    "target_service": "ftp",
                    "severity": "medium",
                    "port": 21,
                    "username": "anonymous",
                    "password": "anonymous"
                }
            ],
            "smb": [
                {
                    "name": "SMB Null Session",
                    "description": "Test for SMB null session vulnerability",
                    "cve": "N/A",
                    "target_service": "smb",
                    "severity": "medium",
                    "port": 445
                },
                {
                    "name": "EternalBlue",
                    "description": "MS17-010 SMB vulnerability",
                    "cve": "CVE-2017-0144",
                    "target_service": "smb",
                    "severity": "critical",
                    "port": 445
                }
            ]
        }
    
    def list_exploits(self):
        """Return all available exploits."""
        return self.exploits_db
    
    def get_matching_exploits(self, target_info):
        """Get exploits that match the target's vulnerabilities."""
        matching_exploits = []
        
        if not target_info or 'ports' not in target_info:
            return matching_exploits
        
        open_ports = target_info.get('ports', [])
        services = target_info.get('services', {})
        
        for category, exploits in self.exploits_db.items():
            for exploit in exploits:
                if self._is_exploit_applicable(exploit, open_ports, services):
                    matching_exploits.append({
                        'category': category,
                        'exploit': exploit
                    })
        
        return matching_exploits
    
    def _is_exploit_applicable(self, exploit, open_ports, services):
        """Check if an exploit is applicable to the target."""
        target_service = exploit.get('target_service')
        target_port = exploit.get('port')
        
        # Check if the required port is open
        if target_port and target_port not in open_ports:
            return False
        
        # Check if the required service is running
        if target_service:
            service_found = False
            for port, service_info in services.items():
                if target_service.lower() in service_info.get('name', '').lower():
                    service_found = True
                    break
                elif target_service == 'http' and port in [80, 443, 8080]:
                    service_found = True
                    break
                elif target_service == 'ssh' and port == 22:
                    service_found = True
                    break
                elif target_service == 'ftp' and port == 21:
                    service_found = True
                    break
                elif target_service == 'smb' and port in [139, 445]:
                    service_found = True
                    break
            
            if not service_found:
                return False
        
        return True
    
    def run_specific_exploit(self, exploit_name, target):
        """Run a specific exploit against a target."""
        exploit_info = None
        category = None
        
        # Find the exploit
        for cat, exploits in self.exploits_db.items():
            for exploit in exploits:
                if exploit['name'].lower() == exploit_name.lower():
                    exploit_info = exploit
                    category = cat
                    break
            if exploit_info:
                break
        
        if not exploit_info:
            return {
                "error": f"Exploit '{exploit_name}' not found",
                "timestamp": get_timestamp()
            }
        
        print(f"[*] Running exploit: {exploit_info['name']}")
        print(f"[*] Target: {target}")
        print(f"[*] Category: {category}")
        
        # Simulate exploit execution
        result = self._execute_exploit(exploit_info, target, category)
        
        return {
            "exploit": exploit_info['name'],
            "target": target,
            "category": category,
            "result": result,
            "timestamp": get_timestamp()
        }
    
    def run_all_matching_exploits(self):
        """Run all exploits that match the scan results."""
        results = []
        
        if not self.scan_results or 'targets' not in self.scan_results:
            return {
                "error": "No valid scan results provided",
                "timestamp": get_timestamp()
            }
        
        for target, target_info in self.scan_results['targets'].items():
            print(f"\n[*] Analyzing target: {target}")
            
            matching_exploits = self.get_matching_exploits(target_info)
            
            if not matching_exploits:
                print(f"[!] No applicable exploits found for {target}")
                continue
            
            print(f"[+] Found {len(matching_exploits)} applicable exploits for {target}")
            
            target_results = {
                "target": target,
                "exploits": []
            }
            
            for match in matching_exploits:
                exploit = match['exploit']
                category = match['category']
                
                print(f"[*] Running {exploit['name']} against {target}")
                
                result = self._execute_exploit(exploit, target, category)
                
                target_results["exploits"].append({
                    "name": exploit['name'],
                    "category": category,
                    "result": result,
                    "timestamp": get_timestamp()
                })
            
            results.append(target_results)
        
        return {
            "exploitation_results": results,
            "total_targets": len(self.scan_results.get('targets', {})),
            "timestamp": get_timestamp()
        }
    
    def _execute_exploit(self, exploit, target, category):
        """Execute an exploit (simulation for safety)."""
        # This is a simulation - in a real tool, you would implement actual exploit code
        # For educational purposes, we'll just simulate the results
        
        try:
            if category == "web":
                return self._simulate_web_exploit(exploit, target)
            elif category == "network":
                return self._simulate_network_exploit(exploit, target)
            elif category == "smb":
                return self._simulate_smb_exploit(exploit, target)
            else:
                return {
                    "status": "unknown_category",
                    "message": f"Unknown exploit category: {category}"
                }
        except Exception as e:
            return {
                "status": "error",
                "message": f"Exploit execution failed: {str(e)}"
            }
    
    def _simulate_web_exploit(self, exploit, target):
        """Simulate web exploitation."""
        # Simulate web vulnerability testing
        if "SQL" in exploit['name']:
            return {
                "status": "tested",
                "vulnerable": False,
                "message": "SQL injection test completed - endpoint appears secure"
            }
        elif "XSS" in exploit['name']:
            return {
                "status": "tested",
                "vulnerable": False,
                "message": "XSS test completed - input validation appears adequate"
            }
        elif "Directory" in exploit['name']:
            return {
                "status": "tested",
                "vulnerable": False,
                "message": "Directory traversal test completed - path restrictions in place"
            }
        
        return {
            "status": "tested",
            "vulnerable": False,
            "message": "Web exploit test completed"
        }
    
    def _simulate_network_exploit(self, exploit, target):
        """Simulate network exploitation."""
        if "SSH" in exploit['name']:
            return {
                "status": "tested",
                "vulnerable": False,
                "message": "SSH brute force test completed - strong authentication detected"
            }
        elif "FTP" in exploit['name']:
            return {
                "status": "tested",
                "vulnerable": False,
                "message": "FTP anonymous access test completed - anonymous login disabled"
            }
        
        return {
            "status": "tested",
            "vulnerable": False,
            "message": "Network exploit test completed"
        }
    
    def _simulate_smb_exploit(self, exploit, target):
        """Simulate SMB exploitation."""
        if "Null Session" in exploit['name']:
            return {
                "status": "tested",
                "vulnerable": False,
                "message": "SMB null session test completed - null sessions disabled"
            }
        elif "EternalBlue" in exploit['name']:
            return {
                "status": "tested",
                "vulnerable": False,
                "message": "EternalBlue test completed - system appears patched"
            }
        
        return {
            "status": "tested",
            "vulnerable": False,
            "message": "SMB exploit test completed"
        }
    
    def generate_report(self, results, output_file=None):
        """Generate an exploitation report."""
        report = {
            "report_id": generate_random_id(),
            "timestamp": get_timestamp(),
            "exploitation_summary": results,
            "metadata": {
                "tool": "VulnAnalyzer Exploiter",
                "version": "1.0.0"
            }
        }
        
        if output_file:
            try:
                with open(output_file, 'w') as f:
                    json.dump(report, f, indent=4)
                print(f"[+] Exploitation report saved to {output_file}")
            except Exception as e:
                print(f"[!] Error saving report: {str(e)}")
        
        return report
